# TIL

***
## 2021-12-15
공부 서적 - 로버트 나일스트롬 '게임 프로그래밍 패턴'

- 코드를 얼마나 쉽게 변경할 수 있느냐가 코드 설계를 평가하는 척도가 된다.
- 코드 수정 : 업무 할당 -> 코드 팍악 -> 문제해결 코드 작성 -> ***코드정리 -> 반복..   
- 코드간 디커플링이 중요한 이유 : 작업에 들어가기 전에 알아야 할 지식의 양이 줄어듬, 즉 어느 한 코드를 고칠때 영향이 가는 다른 코드들의 정보를 알아야할 필요없음.
- 버릴 코드라면 확실히 다시 만들어야 한다는걸 주지 시켜야한다. 버릴 코드를 유지해야할 가능성이 있다면 방어적으로 잘 만들어야 할 필요가 있을지도...

- 구조가 깔끔, 성능 최적화, 기능을 빠르게 구현..  이것 모두는 불가능하므로. 균형이 중요

-저자의 조언
1. 추상화와 디커플링 잘 활용 -> 코드를 점차 쉽고 빠르게 만들 수 있다. 단 고민중엔 코드에 유연함이 필요하다는 확신이 없으면 디커플링 적용하느라 시간낭비X
2. 가정을 코드에 박아 넣어야 하는 저수준의 핵심 최적화는 가능하면 늦게.
3. 버릴코드 잘만들겟다고 시간낭비X
4. **재미있는 걸 만들고 싶다면 먼저 만드는 데에서 재미를 찾자.


## 2021-12-16
- string 문자열 치환
- 프로그래머스 '숫자 문자열과 영단어' 풀이 방법
```c++
#include <iostream>
#include <string>
#include <regex>
int main()
{
  string str = "one2threefour";
  str.replace(0,2, "1")
  cout << str << end;  // 12threefour
  
  str = regex_replace(str, regex("one"), "1");
  str = regex_replace(str, regex("three"), "3");
  str = regex_replace(str, regex("four"), "4");
  cout << str;  // 1234
}
```
## 2021-12-18
- command 패턴 공부
- 메서드 호출을 실체화 : 함수 호출을 객체로 감싸서 콜백을 객체 지향적으로 표현한 것

## 2021-12-20
- 샌드박스 패턴 공부
- 커맨드 패턴을 구현하면서 상위클래스의 하위 클래스가 너무 많아졌을때 샌드박스 패턴으로 발전할 수 있다.
- 상위 클래스는 추상 샌드박스 메서드와 여러 제공 기능을 정의. 제공 기능은 protected로 만들어져 하위 클래스용이라는 것을 분명히 한다.
- 샌드박스 패턴을 사용하다 보면 상위 클래스의 메서드 수가 엄청나게 늘어나는데. 이들중 메서드 일부를 다른 클래스로 옮기면 문제를 완화할 수 있다.

## 2021-12-27
- 경량 패턴 공부
- 객체의 개수가 너무 많아서 가볍게 만들고 싶을때 사용
- 열거형을 선언해 수많은 다중 선택문(switch)을 만들 생각이라면, 경량 패턴을 먼저 고려해 보자

- 프로그래머스 숫자 판단하는 함수  * isdigit()
```c++
include <string>
#include <vector>
using namespace std;

bool solution(string s) {
    bool answer = true;

    for (int i = 0; i < s.size(); i++)
    {
        if (!isdigit(s[i]))
            answer = false;
    }

    return s.size() == 4 || s.size() == 6 ? answer : false;
}

```
## 2021-12-30
 - 프로그래머스 최대공약수와 최소공배수
 - 자꾸 까먹는 공식

```
// 최대 공약수
int gcd(int a, int b)
{
	  if (b == 0) return a;
    return gcd(b, a % b);    
}
// 최소 공배수
int lcm(int a, int b)
{
    return (a * b) / gcd(a,b);
}

```
## 2022-01-03
- Djikstra 알고리즘
- 시작 정점부터 나머지 각 정점까지 최단거리 계산

- 요약 : 첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인집 노드 간의 거리부터 먼저 계산하면서,
        첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트

- 우선순위 큐를 활용

- 1) 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장
     초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장함
     우선순위 큐에 첫정점만 먼저 넣음

- 2) 우선순위 큐에서 노드를 꺼냄
     처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐
     첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교한다.
     배열에 저장되어 있는거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리 업데이트.
     배열해 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 넣는다. ( 결과적으로 bds와 유사하게 첫 정점에 인접한 노드들을 순차 방문)
     (만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리를 가진 노드의 경우에는 해당 노드와 인접한 노드거리 계산하지않음)

- 3) 2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복.

## 2022-01-17
프로그래머스
소수찾기
next_permutation, prev_permutation -> 순열 반환